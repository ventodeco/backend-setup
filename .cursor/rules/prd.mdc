---
description: 
globs: 
alwaysApply: false
---
Here's a full Product Requirements Document (PRD) for a Contract API that will be implemented in Rust using Actix, with SQLx for database access, Dockerfile, docker-compose, and GitHub Actions for CI/CD. We'll break this down into:

PRD
- Folder structure
- Rust + Actix app (using SQLx)
- Dockerfile
- docker-compose.yml
- GitHub Actions workflow (.github/workflows/ci.yml)

ðŸ“„ 1. Product Requirements Document (PRD)
Project Title
Cursor Contract API

Overview
The Backend Contract API is a RESTful web service to authenticate the user using JWT and makes the expiration configurable.

Goals
- Use PostgreSQL as persistent storage.
- Use Actix-web as the HTTP server framework.
- Use SQLx as the async PostgreSQL driver.
- Containerized via Docker.
- CI/CD pipeline via GitHub Actions.
- Ensure we use MVC setup (controllers - for validation and catch the exception, services - put business logic here, repositories - for connecting to database - query)

- Functional Requirements API

# Register user API
URI: [POST] /v1/register 

Logic:
1. Validate the fields
    - email, password, name
2. Check the email on the database
3. If exist, return error code 1002, user already exists
4. Encrypt the password and store to database
5. generate jwt with expiration time
5. return success response

Request
```
{
  "email": "user@example.com",
  "password": "yourpassword",
  "name": "John Doe"
}
```
Response
```
- Success Response
code: 200
{
    "success": true,
    "data": {
        "token": "{token}",
        "expiredAt": "{timestamp}"
    }
}

- Failed Response
code: 422
{
  "success": false,
  "errors": [
    {
      "entity": "BACKEND_PROJECT",
      "code": "1001",
      "cause": "INVALID_EMAIL_OR_PASSWORD"
    }
  ]
}

code: 422
{
  "success": false,
  "errors": [
    {
      "entity": "BACKEND_PROJECT",
      "code": "1002",
      "cause": "USER_ALREADY_EXISTS"
    }
  ]
}

- System error
code: 500
{
  "success": false,
  "errors": [
    {
      "entity": "BACKEND_PROJECT",
      "code": "1000",
      "cause": "SYSTEM_ERROR"
    }
  ]
}
```

# Login user API
URI: [POST] /v1/login 

Logic:
1. Validate the fields
    - email, password
2. Check the email on the database
3. If not exist, return error code 1002, user does not exists
4. Encrypt the password and check with the existing password
5. generate the jwt with expiration time
6. success response

Request
```
{
  "email": "user@example.com",
  "password": "yourpassword"
}
```
Response
```
- Success Response
code: 200
{
    "success": true,
    "data": {
        "token": "{token}",
        "expiredAt": "{timestamp}"
    }
}

- Failed Response
code: 422
{
  "success": false,
  "errors": [
    {
      "entity": "BACKEND_PROJECT",
      "code": "1001",
      "cause": "INVALID_EMAIL_OR_PASSWORD"
    }
  ]
}

- System error
code: 500
{
  "success": false,
  "errors": [
    {
      "entity": "BACKEND_PROJECT",
      "code": "1000",
      "cause": "SYSTEM_ERROR"
    }
  ]
}
```


Database Schema:
```
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at TIMESTAMPZ DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPZ DEFAULT CURRENT_TIMESTAMP
);
```


Non-Functional Requirements
- Fast response time (<100ms)
- JSON API with error handling
- 100% typed with compile-time SQL verification (via SQLx)
- Easily deployable using Docker
- PostgreSQL 14+

Tech Stack
- Language: Rust
- Framework: Actix-web
- ORM/DB: SQLx with PostgreSQL
- Containerization: Docker, docker-compose
- CI/CD: GitHub Actions